<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>グラフの階層的描画</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
</head>
<body>

<h1>グラフの階層的描画</h1>

<div>
状態遷移図を対象としたグラフの階層的描画の実装を目的とする。
</div>

<ol>
  <li>Cycle Removeal</li>
  <li>Layer Assignment</li>
  <li>Edge Concenctration</li>
  <li>Vertex Ordering</li>
  <li>\(x\)-Coordinate Assignment</li>
</ol>

<ol>
  <li>グラフの非閉路化</li>
  <li>頂点集合の階層への分割</li>
  <li>各階層上での頂点順序の決定</li>
  <li>各頂点の座標の決定</li>
</ol>

<ul>
  <li>論文・教科書
    <ol>
      <li><a href="https://cs.brown.edu/~rt/gdhandbook/chapters/hierarchical.pdf">Hierarchical Drawing Algorithms</a></li>
      <li><a href="http://www.graphviz.org/Documentation/TSE93.pdf">A Technique for Drawing Directed Graph</a></li>
      <li><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.64.4457&rep=rep1&type=pdf">Fast and Simple Horizontal Coordinate Assignment</a></li>
      <li><a href="http://jgaa.info/accepted/2004/BarthMutzelJuenger2004.8.2.pdf">Simple and Efficient Bilayer Cross Counting</a></li>
      <li><a href="http://www.researchgate.net/profile/Petra_Mutzel/publication/30508315_2-Layer_Straightline_Crossing_Minimization_Performance_of_Exact_and_Heuristic_Algorithms/links/09e4150eabaf4cc7bd000000.pdf">2-Layer Straightline Crossing Minimization</a></li>
      <li><a href="http://www.lib.kobe-u.ac.jp/repository/thesis2/d1/D1005931.pdf">階層グラフの描画アルゴリズムに関する研究</a></li>
    </ol>
  </li>
  <li>スライド
    <ol>
      <li><a href="https://www.slideshare.net/nikolovn/gd-2001-ver2">How to Layer a Directed Acyclic Graph</a></li>
    </ol>
  </li>
  <li>ウェブページ
    <ol>
      <li><a href="https://kaken.nii.ac.jp/ja/grant/KAKENHI-PROJECT-19500029/">有向グラフの階層的描画を求めるアルゴリズムの設計</a></li>
      <li><a href="http://www2.kobe-u.ac.jp/~ky/labo/research/graph-drawing.htm">グラフ描画アルゴリズムの設計</a></li>
      <li><a href="http://interprism.hatenablog.com/entry/layered_graph">有向グラフの階層表示</a></li>
    </ol>
  </li>
  <li>Wikipedia
    <ol>
      <li><a href="https://en.wikipedia.org/wiki/Layered_graph_drawing">Layered graph drawing</a></li>
      <li><a href="https://en.wikipedia.org/wiki/Transitive_reduction">Transitive reduction</a></li>
      <li><a href="https://en.wikipedia.org/wiki/Coffman%E2%80%93Graham_algorithm">Coffman-Graham algorithm</a></li>
    </ol>
  </li>
  <li>プログラム
    <ol>
      <li><a href="http://www.rw.cdl.uni-saarland.de/~sander/html/gsvcg1.html">VCG</a></li>
      <li><a href="http://www.graphviz.org/">Graphviz</a></li>
      <li><a href="https://github.com/cpettitt/dagre-d3">dagre-d3</a></li>
      <li><a href="https://github.com/cpettitt/dagre/wiki">dagre (wiki)</a></li>
    </ol>
  </li>
</ul>

<h2>13.2 Cycle Removeal</h2>

<div>
アルゴリズムの適用前に自己ループエッジを取りのぞき、多重エッジをまとめる。
</div>

<ul>
  <li>feedback arc set (FAS) 取りのぞくと有向非巡回グラフになるようなエッジの集合。</li>
  <li>feedback set (FS) 向きを反転させると有向非巡回グラフになるようなエッジの集合。</li>
  <li>FSはFASだが、逆は常に成りたつとは限らない。</li>
</ul>

<div>
頂点の線形順序が与えられたら、エッジ集合をふたつの部分集合に分割できる。
\(\mathrm{order}(v)\)が与えられているとき、エッジ集合\(E\)の要素\(e=(u,v)\)について、\(\mathrm{order}(u)\lt\mathrm{order}(v)\)を満たす集合と満たさない集合に分割する。
ふたつの部分集合はどちらもFSである。
</div>

<h2>13.3 Layer Assignment</h2>

<ul>
  <li>The Longest-Path Algorithm</li>
  <li>The Coffman-Graham Algorithm</li>
  <li>Layering with the Minimum Width</li>
  <li>Improvement by Promotion of Vertices</li>
  <li>Network-Simplex Layering Algorithm</li>
  <li>Healy-Nikolov's Branch-and-Cut Algorithm</li>
</ul>

<h3>The Coffman-Graham Algorithm</h3>

<div>
Coffman-Grahamアルゴリズムはふたつのステップからなる。
最初のステップで\(G\)の全頂点に一意なラベル\(\lambda : V \to \mathbb{N}\)を計算する。
第二ステップで頂点を階層に配置する際、ラベルを優先順位として用いる。
最初のステップのラベルの計算は、下記に定義される頂点集合同士の比較を伴う。
下記が成り立つとき、ふたつの頂点集合\(U_1\)と\(U_2\)は\(U_1 \lt U_2\)である。
</div>

<ul>
  <li>\(U_1 = \varnothing\)かつ\(U_2 \ne \varnothing\)。または、</li>
  <li>\(U_1 \ne \varnothing, U_2 \ne \varnothing\)かつ\(\max\{\lambda(v) : v \in U_1\} \lt \max\{\lambda(v) : v \in U_2\}\)。または、</li>
  <li>
    \(U_1 \ne \varnothing, U_2 \ne \varnothing, \max\{\lambda(v) : v \in U_1\} = \max\{\lambda(v) : v \in U_2\}\)かつ
    \(U_1 \setminus \{v : \lambda(v) = \max\{\lambda(v) : v \in U_1\}\} \lt U_2 \setminus \{v : \lambda(v) = \max\{\lambda(v) : v \in U_2\}\}\)。</li>
</ul>

<div>
第二ステップで、下層から上層に向かって各頂点に階層を配置する。
このとき、階層内の頂点数を上限\(W\)以内に保つ。
</div>

<h3>The Coffman-Graham Algorithm (Wikipedia)</h3>

<div>
\(G\)のトポロジカルな順序付けを構築する。
頂点を、それらの入力近傍の位置集合について辞書順に並べる。
このような順序付けを行うためには、
次の条件を満たす頂点\(v\)を択び、ひとつずつ頂点を順序に加える。
まず、\(v\)の入力近傍がすべて既に半順序に加えられていること。
このような頂点の候補は複数存在しえるので、それらの入力近傍で一番最近追加された入力近傍がもっともearlierであること。
ふたつの頂点の候補が同じ入力近傍を共有している場合、二番めに最近追加された入力近傍がearlierであるほうを択ぶ。
以下、この条件を続ける。
</div>

<h2>13.5 Vertex Ordering</h2>

<h3>13.5.1 One-Sided Crossing Minimization</h3>

<ul>
  <li>OLCM = one-layerd crossing minimization</li>
</ul>

<h4>Counting Crossings</h4>

<div>
\(u, v \in V_2\)で、\(u\)が\(v\)の左にあるとき、\(u,v\)に接続するエッジの交差数を\(c_{uv}\)とする。
交差数行列は\(c_{uv}\)を要素に持つ。
\(V_1\)の頂点は固定されていると仮定するので、この行列はOLCMだけに関係する。
</div>

<h4>Exact Methods</h4>

<div>
\(\delta_{ij}^k\)を、階層\(k=1,2\)上の頂点\(i,j\)の順序を表すような0-1変数とする。
この変数から、最小化の目的関数となるような順列\(\pi_i\)のペアの交差数の式を導出する。
つまり、\(\pi_k(i) \lt \pi_k(j)\)ならば\(\delta_{ij}^k = 1\)、そうでなければ\(0\)。
\(\delta_{ij} = 1 - \delta_{ji}\)であることは明らかである。
\[
  \mathrm{C}(\pi_1, \pi_2) = \sum_{i=1}^{n_2-1} \sum_{j=i+1}^{n_2} \sum_{k\in\mathrm{N}(i)} \sum_{l\in\mathrm{N}(j)}
    \delta_{kl}^1 \delta_{ji}^2 + \delta_{lk}^1 \delta_{ij}^2
\]
OLCMの場合、\(\pi_1\)が固定されていると仮定し、交差を最小化するような\(V_2\)の順序\(\pi_2\)を探す。
つまり、下記を最小化したい。
\[
  \mathrm{C}(\pi_2) = \sum_{i=1}^{n_2-1} \sum_{j=i+1}^{n_2} \sum_{k\in\mathrm{N}(i)} \sum_{l\in\mathrm{N}(j)}
    \delta_{kl}^1 \delta_{ji}^2 + \delta_{lk}^1 \delta_{ij}^2
\]
この\(\mathrm{C}(\pi_2)\)は二次項を含むので解くのが難しい。
しかし、\(V_2\)の頂点\(i\)と\(j\)のペアの交差数
\[
  c_{ij} = \sum_{k\in\mathrm{N}(i)} \sum_{l\in\mathrm{N}(j)} \delta_{lk}^1
\]
を用いて、
\[\begin{align}
  \mathrm{C}(\pi_2)
    &amp;= \sum_{i=1}^{n_2-1} \sum_{j=i+1}^{n_2} c_{ji} \delta_{ji}^2 + c_{ij} \delta_{ij}^2 \\
    &amp;= \sum_{i=1}^{n_2-1} \sum_{j=i+1}^{n_2} c_{ji} (1 - \delta_{ij}^2) + c_{ij} \delta_{ij}^2 \\
    &amp;= \sum_{i=1}^{n_2-1} \sum_{j=i+1}^{n_2} (c_{ij} - c_{ji}) \delta_{ij}^2 + c_{ji} \\
    &amp;= \sum_{i=1}^{n_2-1} \sum_{j=i+1}^{n_2} (c_{ij} - c_{ji}) \delta_{ij}^2 + \sum_{i=1}^{n_2-1} \sum_{j=i+1}^{n_2} c_{ji}
\end{align}\]
のように書きなおすことができる。
こうして問題は、頂点を順序づけるようなベクトル\(\delta^2 \in \{0, 1\}^{\begin{pmatrix} n_2 \\ n \end{pmatrix}}\)を探すことに帰着した。
一貫した順序を頂点に与えるために、「3-cycle」制約を強制する。
これは、頂点\(i\)の優先度が頂点\(j\)より高く、頂点\(j\)の優先度が頂点\(k\)より高ければ、頂点\(i\)は頂点\(k\)に優先しなければならないという制約である。
</div>
<div>
\(c_{ij}\)と\(c_{ji}\)は前もって決定することができ、\(\sum_{i=1}^{n_2-1} \sum_{j=i+1}^{n_2} c_{ji}\)は定数なので、問題は下記のように線形計画として書くことができる。
ここで、\(\delta_{ij}^2\)はより一般的な\(x_{ij}\)で置きかえる。
</div>
<div>
\[
  \sum_{i=1}^{n_2} \sum_{j=i+1}^{n_2} a_{ij} x_{ij}を最小化する。
\]
ただし、
\[\begin{align}
    &amp; 0 \le x_{ij} + x_{jk} - x_{ik} \le 1 &amp; 1 \le i \lt j \lt k \le n_2 \\
    &amp; 0 \le x_{ij} \le 1 &amp; 1 \le i \lt j \le n_2 \\
    &amp; x_{ij}は整数 &amp;
\end{align}\]
</div>

<h2>13.6 \(x\)-Coordinate Assignment</h2>

<h3>Fast and Simple Horizontal Coordinate Assignment</h3>

<div>
ダミー頂点間のsegmentをinner segmentsと呼ぶ。
</div>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  CommonHTML: {
    /* scale: 90, */
    undefinedFamily: "sans-serif"
  }
});
</script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML"></script>
</body>
</html>
